// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: MetaData.proto

#include "MetaData.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
extern PROTOBUF_INTERNAL_EXPORT_MetaData_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_File_MetaData_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_MetaData_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<3> scc_info_FileInfo_MetaData_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_MetaData_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_Label_MetaData_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_MetaData_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_Score_MetaData_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_MetaData_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_SongInfo_MetaData_2eproto;
namespace PFAData {
class LabelDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<Label> _instance;
} _Label_default_instance_;
class ScoreDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<Score> _instance;
} _Score_default_instance_;
class SongInfoDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<SongInfo> _instance;
} _SongInfo_default_instance_;
class FileInfoDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<FileInfo> _instance;
} _FileInfo_default_instance_;
class FileDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<File> _instance;
} _File_default_instance_;
class MetaDataDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<MetaData> _instance;
} _MetaData_default_instance_;
class RegistrationDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<Registration> _instance;
} _Registration_default_instance_;
}  // namespace PFAData
static void InitDefaultsscc_info_File_MetaData_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::PFAData::_File_default_instance_;
    new (ptr) ::PFAData::File();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::PFAData::File::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_File_MetaData_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_File_MetaData_2eproto}, {}};

static void InitDefaultsscc_info_FileInfo_MetaData_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::PFAData::_FileInfo_default_instance_;
    new (ptr) ::PFAData::FileInfo();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::PFAData::FileInfo::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<3> scc_info_FileInfo_MetaData_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 3, 0, InitDefaultsscc_info_FileInfo_MetaData_2eproto}, {
      &scc_info_SongInfo_MetaData_2eproto.base,
      &scc_info_Label_MetaData_2eproto.base,
      &scc_info_Score_MetaData_2eproto.base,}};

static void InitDefaultsscc_info_Label_MetaData_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::PFAData::_Label_default_instance_;
    new (ptr) ::PFAData::Label();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::PFAData::Label::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_Label_MetaData_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_Label_MetaData_2eproto}, {}};

static void InitDefaultsscc_info_MetaData_MetaData_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::PFAData::_MetaData_default_instance_;
    new (ptr) ::PFAData::MetaData();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::PFAData::MetaData::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<2> scc_info_MetaData_MetaData_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 2, 0, InitDefaultsscc_info_MetaData_MetaData_2eproto}, {
      &scc_info_File_MetaData_2eproto.base,
      &scc_info_FileInfo_MetaData_2eproto.base,}};

static void InitDefaultsscc_info_Registration_MetaData_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::PFAData::_Registration_default_instance_;
    new (ptr) ::PFAData::Registration();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::PFAData::Registration::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_Registration_MetaData_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_Registration_MetaData_2eproto}, {}};

static void InitDefaultsscc_info_Score_MetaData_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::PFAData::_Score_default_instance_;
    new (ptr) ::PFAData::Score();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::PFAData::Score::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_Score_MetaData_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_Score_MetaData_2eproto}, {}};

static void InitDefaultsscc_info_SongInfo_MetaData_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::PFAData::_SongInfo_default_instance_;
    new (ptr) ::PFAData::SongInfo();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::PFAData::SongInfo::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_SongInfo_MetaData_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_SongInfo_MetaData_2eproto}, {}};

namespace PFAData {

// ===================================================================

void Label::InitAsDefaultInstance() {
}
class Label::_Internal {
 public:
  using HasBits = decltype(std::declval<Label>()._has_bits_);
  static void set_has_pos(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_label(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

Label::Label(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:PFAData.Label)
}
Label::Label(const Label& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  label_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_label()) {
    label_.SetLite(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_label(),
      GetArena());
  }
  pos_ = from.pos_;
  // @@protoc_insertion_point(copy_constructor:PFAData.Label)
}

void Label::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_Label_MetaData_2eproto.base);
  label_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  pos_ = 0;
}

Label::~Label() {
  // @@protoc_insertion_point(destructor:PFAData.Label)
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

void Label::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  label_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void Label::ArenaDtor(void* object) {
  Label* _this = reinterpret_cast< Label* >(object);
  (void)_this;
}
void Label::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void Label::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Label& Label::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_Label_MetaData_2eproto.base);
  return *internal_default_instance();
}


void Label::Clear() {
// @@protoc_insertion_point(message_clear_start:PFAData.Label)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    label_.ClearNonDefaultToEmpty();
  }
  pos_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* Label::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required int32 pos = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_pos(&has_bits);
          pos_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required string label = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          auto str = _internal_mutable_label();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<std::string>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* Label::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:PFAData.Label)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required int32 pos = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(1, this->_internal_pos(), target);
  }

  // required string label = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_label(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:PFAData.Label)
  return target;
}

size_t Label::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:PFAData.Label)
  size_t total_size = 0;

  if (_internal_has_label()) {
    // required string label = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_label());
  }

  if (_internal_has_pos()) {
    // required int32 pos = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
        this->_internal_pos());
  }

  return total_size;
}
size_t Label::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:PFAData.Label)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required string label = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_label());

    // required int32 pos = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
        this->_internal_pos());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Label::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const Label*>(
      &from));
}

void Label::MergeFrom(const Label& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:PFAData.Label)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_label(from._internal_label());
    }
    if (cached_has_bits & 0x00000002u) {
      pos_ = from.pos_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void Label::CopyFrom(const Label& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:PFAData.Label)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Label::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void Label::InternalSwap(Label* other) {
  using std::swap;
  _internal_metadata_.Swap<std::string>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  label_.Swap(&other->label_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  swap(pos_, other->pos_);
}

std::string Label::GetTypeName() const {
  return "PFAData.Label";
}


// ===================================================================

void Score::InitAsDefaultInstance() {
}
class Score::_Internal {
 public:
  using HasBits = decltype(std::declval<Score>()._has_bits_);
  static void set_has_score(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_mult(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_missed(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_incorrect(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_ok(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_good(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_great(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_curstreak(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_goodstreak(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_badstreak(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_date(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

Score::Score(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:PFAData.Score)
}
Score::Score(const Score& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&score_, &from.score_,
    static_cast<size_t>(reinterpret_cast<char*>(&mult_) -
    reinterpret_cast<char*>(&score_)) + sizeof(mult_));
  // @@protoc_insertion_point(copy_constructor:PFAData.Score)
}

void Score::SharedCtor() {
  ::memset(&score_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&date_) -
      reinterpret_cast<char*>(&score_)) + sizeof(date_));
  mult_ = 10;
}

Score::~Score() {
  // @@protoc_insertion_point(destructor:PFAData.Score)
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

void Score::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
}

void Score::ArenaDtor(void* object) {
  Score* _this = reinterpret_cast< Score* >(object);
  (void)_this;
}
void Score::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void Score::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Score& Score::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_Score_MetaData_2eproto.base);
  return *internal_default_instance();
}


void Score::Clear() {
// @@protoc_insertion_point(message_clear_start:PFAData.Score)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    ::memset(&score_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&goodstreak_) -
        reinterpret_cast<char*>(&score_)) + sizeof(goodstreak_));
  }
  if (cached_has_bits & 0x00000700u) {
    ::memset(&badstreak_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&date_) -
        reinterpret_cast<char*>(&badstreak_)) + sizeof(date_));
    mult_ = 10;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* Score::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required sint32 score = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_score(&has_bits);
          score_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarintZigZag32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 mult = 2 [default = 10];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_mult(&has_bits);
          mult_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 missed = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_missed(&has_bits);
          missed_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 incorrect = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_incorrect(&has_bits);
          incorrect_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 ok = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          _Internal::set_has_ok(&has_bits);
          ok_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 good = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 48)) {
          _Internal::set_has_good(&has_bits);
          good_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 great = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 56)) {
          _Internal::set_has_great(&has_bits);
          great_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional sint32 curStreak = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 64)) {
          _Internal::set_has_curstreak(&has_bits);
          curstreak_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarintZigZag32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 goodStreak = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 72)) {
          _Internal::set_has_goodstreak(&has_bits);
          goodstreak_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 badStreak = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 80)) {
          _Internal::set_has_badstreak(&has_bits);
          badstreak_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 date = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 88)) {
          _Internal::set_has_date(&has_bits);
          date_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<std::string>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* Score::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:PFAData.Score)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required sint32 score = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteSInt32ToArray(1, this->_internal_score(), target);
  }

  // optional int32 mult = 2 [default = 10];
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(2, this->_internal_mult(), target);
  }

  // optional int32 missed = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(3, this->_internal_missed(), target);
  }

  // optional int32 incorrect = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(4, this->_internal_incorrect(), target);
  }

  // optional int32 ok = 5;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(5, this->_internal_ok(), target);
  }

  // optional int32 good = 6;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(6, this->_internal_good(), target);
  }

  // optional int32 great = 7;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(7, this->_internal_great(), target);
  }

  // optional sint32 curStreak = 8;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteSInt32ToArray(8, this->_internal_curstreak(), target);
  }

  // optional int32 goodStreak = 9;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(9, this->_internal_goodstreak(), target);
  }

  // optional int32 badStreak = 10;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(10, this->_internal_badstreak(), target);
  }

  // optional int32 date = 11;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(11, this->_internal_date(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:PFAData.Score)
  return target;
}

size_t Score::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:PFAData.Score)
  size_t total_size = 0;

  // required sint32 score = 1;
  if (_internal_has_score()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SInt32Size(
        this->_internal_score());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000feu) {
    // optional int32 missed = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->_internal_missed());
    }

    // optional int32 incorrect = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->_internal_incorrect());
    }

    // optional int32 ok = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->_internal_ok());
    }

    // optional int32 good = 6;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->_internal_good());
    }

    // optional int32 great = 7;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->_internal_great());
    }

    // optional sint32 curStreak = 8;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SInt32Size(
          this->_internal_curstreak());
    }

    // optional int32 goodStreak = 9;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->_internal_goodstreak());
    }

  }
  if (cached_has_bits & 0x00000700u) {
    // optional int32 badStreak = 10;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->_internal_badstreak());
    }

    // optional int32 date = 11;
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->_internal_date());
    }

    // optional int32 mult = 2 [default = 10];
    if (cached_has_bits & 0x00000400u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->_internal_mult());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Score::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const Score*>(
      &from));
}

void Score::MergeFrom(const Score& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:PFAData.Score)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      score_ = from.score_;
    }
    if (cached_has_bits & 0x00000002u) {
      missed_ = from.missed_;
    }
    if (cached_has_bits & 0x00000004u) {
      incorrect_ = from.incorrect_;
    }
    if (cached_has_bits & 0x00000008u) {
      ok_ = from.ok_;
    }
    if (cached_has_bits & 0x00000010u) {
      good_ = from.good_;
    }
    if (cached_has_bits & 0x00000020u) {
      great_ = from.great_;
    }
    if (cached_has_bits & 0x00000040u) {
      curstreak_ = from.curstreak_;
    }
    if (cached_has_bits & 0x00000080u) {
      goodstreak_ = from.goodstreak_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000700u) {
    if (cached_has_bits & 0x00000100u) {
      badstreak_ = from.badstreak_;
    }
    if (cached_has_bits & 0x00000200u) {
      date_ = from.date_;
    }
    if (cached_has_bits & 0x00000400u) {
      mult_ = from.mult_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void Score::CopyFrom(const Score& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:PFAData.Score)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Score::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void Score::InternalSwap(Score* other) {
  using std::swap;
  _internal_metadata_.Swap<std::string>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Score, date_)
      + sizeof(Score::date_)
      - PROTOBUF_FIELD_OFFSET(Score, score_)>(
          reinterpret_cast<char*>(&score_),
          reinterpret_cast<char*>(&other->score_));
  swap(mult_, other->mult_);
}

std::string Score::GetTypeName() const {
  return "PFAData.Score";
}


// ===================================================================

void SongInfo::InitAsDefaultInstance() {
}
class SongInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<SongInfo>()._has_bits_);
  static void set_has_md5(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_division(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_notes(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_beats(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_seconds(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_tracks(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_plays(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

SongInfo::SongInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:PFAData.SongInfo)
}
SongInfo::SongInfo(const SongInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  md5_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_md5()) {
    md5_.SetLite(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_md5(),
      GetArena());
  }
  ::memcpy(&division_, &from.division_,
    static_cast<size_t>(reinterpret_cast<char*>(&plays_) -
    reinterpret_cast<char*>(&division_)) + sizeof(plays_));
  // @@protoc_insertion_point(copy_constructor:PFAData.SongInfo)
}

void SongInfo::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_SongInfo_MetaData_2eproto.base);
  md5_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  ::memset(&division_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&plays_) -
      reinterpret_cast<char*>(&division_)) + sizeof(plays_));
}

SongInfo::~SongInfo() {
  // @@protoc_insertion_point(destructor:PFAData.SongInfo)
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

void SongInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  md5_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void SongInfo::ArenaDtor(void* object) {
  SongInfo* _this = reinterpret_cast< SongInfo* >(object);
  (void)_this;
}
void SongInfo::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void SongInfo::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const SongInfo& SongInfo::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_SongInfo_MetaData_2eproto.base);
  return *internal_default_instance();
}


void SongInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:PFAData.SongInfo)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    md5_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x0000007eu) {
    ::memset(&division_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&plays_) -
        reinterpret_cast<char*>(&division_)) + sizeof(plays_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* SongInfo::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required bytes md5 = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          auto str = _internal_mutable_md5();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 division = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_division(&has_bits);
          division_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 notes = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_notes(&has_bits);
          notes_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 beats = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_beats(&has_bits);
          beats_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 seconds = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          _Internal::set_has_seconds(&has_bits);
          seconds_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 tracks = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 48)) {
          _Internal::set_has_tracks(&has_bits);
          tracks_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 plays = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 56)) {
          _Internal::set_has_plays(&has_bits);
          plays_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<std::string>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* SongInfo::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:PFAData.SongInfo)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required bytes md5 = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_md5(), target);
  }

  // optional int32 division = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(2, this->_internal_division(), target);
  }

  // optional int32 notes = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(3, this->_internal_notes(), target);
  }

  // optional int32 beats = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(4, this->_internal_beats(), target);
  }

  // optional int32 seconds = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(5, this->_internal_seconds(), target);
  }

  // optional int32 tracks = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(6, this->_internal_tracks(), target);
  }

  // optional int32 plays = 7;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(7, this->_internal_plays(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:PFAData.SongInfo)
  return target;
}

size_t SongInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:PFAData.SongInfo)
  size_t total_size = 0;

  // required bytes md5 = 1;
  if (_internal_has_md5()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_md5());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000007eu) {
    // optional int32 division = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->_internal_division());
    }

    // optional int32 notes = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->_internal_notes());
    }

    // optional int32 beats = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->_internal_beats());
    }

    // optional int32 seconds = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->_internal_seconds());
    }

    // optional int32 tracks = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->_internal_tracks());
    }

    // optional int32 plays = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->_internal_plays());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void SongInfo::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const SongInfo*>(
      &from));
}

void SongInfo::MergeFrom(const SongInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:PFAData.SongInfo)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_md5(from._internal_md5());
    }
    if (cached_has_bits & 0x00000002u) {
      division_ = from.division_;
    }
    if (cached_has_bits & 0x00000004u) {
      notes_ = from.notes_;
    }
    if (cached_has_bits & 0x00000008u) {
      beats_ = from.beats_;
    }
    if (cached_has_bits & 0x00000010u) {
      seconds_ = from.seconds_;
    }
    if (cached_has_bits & 0x00000020u) {
      tracks_ = from.tracks_;
    }
    if (cached_has_bits & 0x00000040u) {
      plays_ = from.plays_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void SongInfo::CopyFrom(const SongInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:PFAData.SongInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SongInfo::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void SongInfo::InternalSwap(SongInfo* other) {
  using std::swap;
  _internal_metadata_.Swap<std::string>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  md5_.Swap(&other->md5_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SongInfo, plays_)
      + sizeof(SongInfo::plays_)
      - PROTOBUF_FIELD_OFFSET(SongInfo, division_)>(
          reinterpret_cast<char*>(&division_),
          reinterpret_cast<char*>(&other->division_));
}

std::string SongInfo::GetTypeName() const {
  return "PFAData.SongInfo";
}


// ===================================================================

void FileInfo::InitAsDefaultInstance() {
  ::PFAData::_FileInfo_default_instance_._instance.get_mutable()->info_ = const_cast< ::PFAData::SongInfo*>(
      ::PFAData::SongInfo::internal_default_instance());
}
class FileInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<FileInfo>()._has_bits_);
  static const ::PFAData::SongInfo& info(const FileInfo* msg);
  static void set_has_info(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

const ::PFAData::SongInfo&
FileInfo::_Internal::info(const FileInfo* msg) {
  return *msg->info_;
}
FileInfo::FileInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena),
  label_(arena),
  top10_(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:PFAData.FileInfo)
}
FileInfo::FileInfo(const FileInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_),
      label_(from.label_),
      top10_(from.top10_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_info()) {
    info_ = new ::PFAData::SongInfo(*from.info_);
  } else {
    info_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:PFAData.FileInfo)
}

void FileInfo::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_FileInfo_MetaData_2eproto.base);
  info_ = nullptr;
}

FileInfo::~FileInfo() {
  // @@protoc_insertion_point(destructor:PFAData.FileInfo)
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

void FileInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  if (this != internal_default_instance()) delete info_;
}

void FileInfo::ArenaDtor(void* object) {
  FileInfo* _this = reinterpret_cast< FileInfo* >(object);
  (void)_this;
}
void FileInfo::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void FileInfo::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const FileInfo& FileInfo::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_FileInfo_MetaData_2eproto.base);
  return *internal_default_instance();
}


void FileInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:PFAData.FileInfo)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  label_.Clear();
  top10_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(info_ != nullptr);
    info_->Clear();
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* FileInfo::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required .PFAData.SongInfo info = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_info(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated .PFAData.Label label = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_label(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else goto handle_unusual;
        continue;
      // repeated .PFAData.Score top10 = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_top10(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<std::string>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* FileInfo::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:PFAData.FileInfo)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .PFAData.SongInfo info = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::info(this), target, stream);
  }

  // repeated .PFAData.Label label = 2;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_label_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, this->_internal_label(i), target, stream);
  }

  // repeated .PFAData.Score top10 = 3;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_top10_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, this->_internal_top10(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:PFAData.FileInfo)
  return target;
}

size_t FileInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:PFAData.FileInfo)
  size_t total_size = 0;

  // required .PFAData.SongInfo info = 1;
  if (_internal_has_info()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *info_);
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .PFAData.Label label = 2;
  total_size += 1UL * this->_internal_label_size();
  for (const auto& msg : this->label_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .PFAData.Score top10 = 3;
  total_size += 1UL * this->_internal_top10_size();
  for (const auto& msg : this->top10_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void FileInfo::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const FileInfo*>(
      &from));
}

void FileInfo::MergeFrom(const FileInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:PFAData.FileInfo)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  label_.MergeFrom(from.label_);
  top10_.MergeFrom(from.top10_);
  if (from._internal_has_info()) {
    _internal_mutable_info()->::PFAData::SongInfo::MergeFrom(from._internal_info());
  }
}

void FileInfo::CopyFrom(const FileInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:PFAData.FileInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FileInfo::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(label_)) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(top10_)) return false;
  if (_internal_has_info()) {
    if (!info_->IsInitialized()) return false;
  }
  return true;
}

void FileInfo::InternalSwap(FileInfo* other) {
  using std::swap;
  _internal_metadata_.Swap<std::string>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  label_.InternalSwap(&other->label_);
  top10_.InternalSwap(&other->top10_);
  swap(info_, other->info_);
}

std::string FileInfo::GetTypeName() const {
  return "PFAData.FileInfo";
}


// ===================================================================

void File::InitAsDefaultInstance() {
}
class File::_Internal {
 public:
  using HasBits = decltype(std::declval<File>()._has_bits_);
  static void set_has_filename(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_filesize(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_infopos(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000007) ^ 0x00000007) != 0;
  }
};

File::File(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:PFAData.File)
}
File::File(const File& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  filename_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_filename()) {
    filename_.SetLite(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_filename(),
      GetArena());
  }
  ::memcpy(&filesize_, &from.filesize_,
    static_cast<size_t>(reinterpret_cast<char*>(&infopos_) -
    reinterpret_cast<char*>(&filesize_)) + sizeof(infopos_));
  // @@protoc_insertion_point(copy_constructor:PFAData.File)
}

void File::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_File_MetaData_2eproto.base);
  filename_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  ::memset(&filesize_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&infopos_) -
      reinterpret_cast<char*>(&filesize_)) + sizeof(infopos_));
}

File::~File() {
  // @@protoc_insertion_point(destructor:PFAData.File)
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

void File::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  filename_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void File::ArenaDtor(void* object) {
  File* _this = reinterpret_cast< File* >(object);
  (void)_this;
}
void File::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void File::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const File& File::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_File_MetaData_2eproto.base);
  return *internal_default_instance();
}


void File::Clear() {
// @@protoc_insertion_point(message_clear_start:PFAData.File)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    filename_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&filesize_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&infopos_) -
        reinterpret_cast<char*>(&filesize_)) + sizeof(infopos_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* File::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required string fileName = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          auto str = _internal_mutable_filename();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required int32 fileSize = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_filesize(&has_bits);
          filesize_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required int32 infoPos = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_infopos(&has_bits);
          infopos_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<std::string>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* File::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:PFAData.File)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required string fileName = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_filename(), target);
  }

  // required int32 fileSize = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(2, this->_internal_filesize(), target);
  }

  // required int32 infoPos = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(3, this->_internal_infopos(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:PFAData.File)
  return target;
}

size_t File::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:PFAData.File)
  size_t total_size = 0;

  if (_internal_has_filename()) {
    // required string fileName = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_filename());
  }

  if (_internal_has_filesize()) {
    // required int32 fileSize = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
        this->_internal_filesize());
  }

  if (_internal_has_infopos()) {
    // required int32 infoPos = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
        this->_internal_infopos());
  }

  return total_size;
}
size_t File::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:PFAData.File)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000007) ^ 0x00000007) == 0) {  // All required fields are present.
    // required string fileName = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_filename());

    // required int32 fileSize = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
        this->_internal_filesize());

    // required int32 infoPos = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
        this->_internal_infopos());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void File::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const File*>(
      &from));
}

void File::MergeFrom(const File& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:PFAData.File)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_filename(from._internal_filename());
    }
    if (cached_has_bits & 0x00000002u) {
      filesize_ = from.filesize_;
    }
    if (cached_has_bits & 0x00000004u) {
      infopos_ = from.infopos_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void File::CopyFrom(const File& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:PFAData.File)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool File::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void File::InternalSwap(File* other) {
  using std::swap;
  _internal_metadata_.Swap<std::string>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  filename_.Swap(&other->filename_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(File, infopos_)
      + sizeof(File::infopos_)
      - PROTOBUF_FIELD_OFFSET(File, filesize_)>(
          reinterpret_cast<char*>(&filesize_),
          reinterpret_cast<char*>(&other->filesize_));
}

std::string File::GetTypeName() const {
  return "PFAData.File";
}


// ===================================================================

void MetaData::InitAsDefaultInstance() {
}
class MetaData::_Internal {
 public:
};

MetaData::MetaData(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena),
  file_(arena),
  fileinfo_(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:PFAData.MetaData)
}
MetaData::MetaData(const MetaData& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      file_(from.file_),
      fileinfo_(from.fileinfo_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:PFAData.MetaData)
}

void MetaData::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_MetaData_MetaData_2eproto.base);
}

MetaData::~MetaData() {
  // @@protoc_insertion_point(destructor:PFAData.MetaData)
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

void MetaData::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
}

void MetaData::ArenaDtor(void* object) {
  MetaData* _this = reinterpret_cast< MetaData* >(object);
  (void)_this;
}
void MetaData::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void MetaData::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const MetaData& MetaData::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_MetaData_MetaData_2eproto.base);
  return *internal_default_instance();
}


void MetaData::Clear() {
// @@protoc_insertion_point(message_clear_start:PFAData.MetaData)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  file_.Clear();
  fileinfo_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* MetaData::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // repeated .PFAData.File file = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_file(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else goto handle_unusual;
        continue;
      // repeated .PFAData.FileInfo fileInfo = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_fileinfo(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<std::string>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* MetaData::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:PFAData.MetaData)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .PFAData.File file = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_file_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, this->_internal_file(i), target, stream);
  }

  // repeated .PFAData.FileInfo fileInfo = 2;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_fileinfo_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, this->_internal_fileinfo(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:PFAData.MetaData)
  return target;
}

size_t MetaData::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:PFAData.MetaData)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .PFAData.File file = 1;
  total_size += 1UL * this->_internal_file_size();
  for (const auto& msg : this->file_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .PFAData.FileInfo fileInfo = 2;
  total_size += 1UL * this->_internal_fileinfo_size();
  for (const auto& msg : this->fileinfo_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void MetaData::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const MetaData*>(
      &from));
}

void MetaData::MergeFrom(const MetaData& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:PFAData.MetaData)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  file_.MergeFrom(from.file_);
  fileinfo_.MergeFrom(from.fileinfo_);
}

void MetaData::CopyFrom(const MetaData& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:PFAData.MetaData)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MetaData::IsInitialized() const {
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(file_)) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(fileinfo_)) return false;
  return true;
}

void MetaData::InternalSwap(MetaData* other) {
  using std::swap;
  _internal_metadata_.Swap<std::string>(&other->_internal_metadata_);
  file_.InternalSwap(&other->file_);
  fileinfo_.InternalSwap(&other->fileinfo_);
}

std::string MetaData::GetTypeName() const {
  return "PFAData.MetaData";
}


// ===================================================================

void Registration::InitAsDefaultInstance() {
}
class Registration::_Internal {
 public:
  using HasBits = decltype(std::declval<Registration>()._has_bits_);
  static void set_has_displayname(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_key(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_date(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

Registration::Registration(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:PFAData.Registration)
}
Registration::Registration(const Registration& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  displayname_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_displayname()) {
    displayname_.SetLite(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_displayname(),
      GetArena());
  }
  name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_name()) {
    name_.SetLite(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_name(),
      GetArena());
  }
  key_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_key()) {
    key_.SetLite(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_key(),
      GetArena());
  }
  date_ = from.date_;
  // @@protoc_insertion_point(copy_constructor:PFAData.Registration)
}

void Registration::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_Registration_MetaData_2eproto.base);
  displayname_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  key_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  date_ = 0;
}

Registration::~Registration() {
  // @@protoc_insertion_point(destructor:PFAData.Registration)
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

void Registration::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  displayname_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  key_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void Registration::ArenaDtor(void* object) {
  Registration* _this = reinterpret_cast< Registration* >(object);
  (void)_this;
}
void Registration::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void Registration::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Registration& Registration::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_Registration_MetaData_2eproto.base);
  return *internal_default_instance();
}


void Registration::Clear() {
// @@protoc_insertion_point(message_clear_start:PFAData.Registration)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      displayname_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      key_.ClearNonDefaultToEmpty();
    }
  }
  date_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* Registration::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional string displayname = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          auto str = _internal_mutable_displayname();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string name = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          auto str = _internal_mutable_name();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bytes key = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          auto str = _internal_mutable_key();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 date = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_date(&has_bits);
          date_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<std::string>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* Registration::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:PFAData.Registration)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string displayname = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_displayname(), target);
  }

  // optional string name = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_name(), target);
  }

  // optional bytes key = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteBytesMaybeAliased(
        3, this->_internal_key(), target);
  }

  // optional int32 date = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(4, this->_internal_date(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:PFAData.Registration)
  return target;
}

size_t Registration::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:PFAData.Registration)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional string displayname = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_displayname());
    }

    // optional string name = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_name());
    }

    // optional bytes key = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_key());
    }

    // optional int32 date = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->_internal_date());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Registration::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const Registration*>(
      &from));
}

void Registration::MergeFrom(const Registration& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:PFAData.Registration)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_displayname(from._internal_displayname());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_name(from._internal_name());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_set_key(from._internal_key());
    }
    if (cached_has_bits & 0x00000008u) {
      date_ = from.date_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void Registration::CopyFrom(const Registration& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:PFAData.Registration)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Registration::IsInitialized() const {
  return true;
}

void Registration::InternalSwap(Registration* other) {
  using std::swap;
  _internal_metadata_.Swap<std::string>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  displayname_.Swap(&other->displayname_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  name_.Swap(&other->name_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  key_.Swap(&other->key_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  swap(date_, other->date_);
}

std::string Registration::GetTypeName() const {
  return "PFAData.Registration";
}


// @@protoc_insertion_point(namespace_scope)
}  // namespace PFAData
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::PFAData::Label* Arena::CreateMaybeMessage< ::PFAData::Label >(Arena* arena) {
  return Arena::CreateMessageInternal< ::PFAData::Label >(arena);
}
template<> PROTOBUF_NOINLINE ::PFAData::Score* Arena::CreateMaybeMessage< ::PFAData::Score >(Arena* arena) {
  return Arena::CreateMessageInternal< ::PFAData::Score >(arena);
}
template<> PROTOBUF_NOINLINE ::PFAData::SongInfo* Arena::CreateMaybeMessage< ::PFAData::SongInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::PFAData::SongInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::PFAData::FileInfo* Arena::CreateMaybeMessage< ::PFAData::FileInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::PFAData::FileInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::PFAData::File* Arena::CreateMaybeMessage< ::PFAData::File >(Arena* arena) {
  return Arena::CreateMessageInternal< ::PFAData::File >(arena);
}
template<> PROTOBUF_NOINLINE ::PFAData::MetaData* Arena::CreateMaybeMessage< ::PFAData::MetaData >(Arena* arena) {
  return Arena::CreateMessageInternal< ::PFAData::MetaData >(arena);
}
template<> PROTOBUF_NOINLINE ::PFAData::Registration* Arena::CreateMaybeMessage< ::PFAData::Registration >(Arena* arena) {
  return Arena::CreateMessageInternal< ::PFAData::Registration >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
